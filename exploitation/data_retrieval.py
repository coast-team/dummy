from os import listdir
from os.path import isfile, isdir
from copy import deepcopy
import sys
import re
import json
import threading

result_data = []


def get_list_files(path_to_dir):
    regexp = re.compile(r'^records-*.')
    list_files = [f for f in listdir(path_to_dir) if isfile(''.join(
        (path_to_dir, f)))]
    return [''.join((path_to_dir, f))
            for f in list_files if re.search(regexp, f) is not None]


def read_file(path):
    global result_data
    collab_record = {}

    with open(path, 'r') as records_file:
        content = records_file.read()
    content_json = json.loads(content)
    traces = content_json['traces']

    for trace in traces:
        if len(trace) >= 2:
            records = {}
            for line in trace[1:-1]:
                split_line = line.split(' ')
                word = split_line[2]
                if word not in records:
                    records[word] = []
                records[word].append((int(split_line[0]), split_line[1]))
            if trace[0] == 'READER':
                collab_record['reader_records'] = records
                collab_record['reader_hash'] = trace[-1][len('HASH '):]
            elif trace[0] == 'WRITER':
                collab_record['writer_records'] = records
                collab_record['writer_hash'] = trace[-1][len('HASH '):]
            else:
                print('skip')
    collab_record['collab_address'] = path.split('-')[1]
    result_data.append(collab_record)


def retrieve_data(path_to_dir):
    print('==== Retrieving data from : ====')
    list_files = get_list_files(path_to_dir)

    [print(f) for f in list_files]

    threads = []
    for path in list_files:
        thread = threading.Thread(target=read_file, args=(path,))
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()


def get_nearest(time, changes_read):
    min_dist = time - changes_read[0][0]
    min_index = 0
    for index, change in enumerate(changes_read):
        if time < change[0]:
            new_dist = change[0] - time
            if min_dist < 0 or min_dist > new_dist:
                min_dist = new_dist
                min_index = index
    relevant_change = changes_read[min_index]
    del changes_read[min_index]
    return relevant_change


def compute_delay():
    global result_data
    print("=== Compute Delay ===")
    data = deepcopy(result_data)
    results = []

    for writer in data:
        for writer_record in writer['writer_records'].items():
            word_written = writer_record[0]
            changes_made = writer_record[1]
            for reader in data:
                if word_written in reader['reader_records']:
                    for change in changes_made:
                        timestamp = change[0]
                        relevant_change = get_nearest(timestamp,
                                                      reader['reader_records'][
                                                          word_written])
                        delay = relevant_change[0] - timestamp
                        entry_result = (writer['collab_address'],
                                        reader['collab_address'],
                                        word_written,
                                        delay)
                        results.append(entry_result)
                        if len(reader['reader_records'][word_written]) <= 0:
                            del reader['reader_records'][word_written]
                            break
    print(data)
    return results


if __name__ == '__main__':
    if len(sys.argv) < 2:
        sys.exit("[Usage] %s path_to_dir" % sys.argv[0])

    path_to_dir = sys.argv[1]
    if not isdir(path_to_dir):
        print('The path to sources dir given is not correct')
        sys.exit(1)
    retrieve_data(path_to_dir)
    # print(result_data)
    res = compute_delay()
    total = 0
    for r in res:
        total += r[3]
    print(total / float(len(res)))
    # print(res)
